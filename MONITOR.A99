;
;---MONITOR AND FDC INTERFACE ROUTINES for the TI99000 SBC
;
;	The monitor routines are called from a DOS or other 
;	programme to perform Console I/O and Disc I/O similar
;	to a BIOS.

;	Version 2.0	14th May 2020 - The year of the Corona Virus
;
;   Written by Alex Cameron
;
R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
;R7	EQU	7   
R8	EQU	8
R9	EQU	9			;Use to index workspace pointer not stack overflow
SL	EQU	R9			;STACK LIMIT
R10	EQU	10
;SP	EQU	R10			;STACK POINTER
R11	EQU	11
R12	EQU	12
PORT	EQU	R12			;IO BASE
R13	EQU	13
R14	EQU	14
R15	EQU	15
;
;***************************************************
;
;	DEFINE SOME XOP'S
;
;****************************************************
;
	DXOP	PUSHREG,4	;PUSH RANGE OF REGISTERS TO STACH
	DXOP	POPREG,5	
	DXOP	CALL,6
	DXOP	RET,7
	DXOP	PUSH,8		;PUSH SINGLE REGISTER
	DXOP	POP,9
	DXOP	WHEX,10		;WRITE OUT A 16 BIT HEX VALUE
	DXOP	RHEX,11		;READ IN A 16 BIT HEX VALUE
	DXOP	WRITE,12	;WRITE CHAR IN MSB
	DXOP	READ,13		;READ CHAR IN MSB
	DXOP	MESG,14		;OUTPUT NULL TERMINATED MESSAGE
;
; SOME EQUATES
;
TIMON	EQU	0F000H
SHELL	EQU	0CA00H
MONORG	EQU	0E600H		;ORIGIN FOR THIS MONITOR
STACKP	EQU	MONORG - 2
STACKL	EQU	STACKP - 32	;ALLOW 32 WORDS FOR STACK, THIS IS ONLY USED FOR MONITOR AND NOT LOADED PROGRAMMES
INTVEC	EQU	08H
LOADER	EQU	0500H		; THIS IS NOT THE CORRECTO LOCATION A SINGLE SECTOR BUFFER (TEMPORARY)

;NOTE DOS IS NOT KNOWN TO MONITOR.  THESE WILL BE REMOVED IN TIME
;DOS IS SETUP BY SHELL
;BDOSWPV	EQU	084H		;BDOS WP VECTOR
;BDOSPCV	EQU	086H		;BDOS VECTOR
;BDOS	EQU	BDOSWPV

	AORG	MONORG
;
;************************************************************************************
;
;	NOTE ALL PROGRAMMES MUST SET THE WORSPACE
;	POINTERS AND STACKS BEFORE CALLING
;
;	NOTE THE FIRST VECTOR BLWP - CALLED ONCE TO INITIALISE MONITOR
;
;*************************************************************************************
;
ENTRY	WORD	WORKSP		;THIS IS MONITOR WORKSAPCE
	WORD	INIT		;INITIALISE ALL XOP, INTERRUPT AND ENTRY VECTORS

	B	@CIN		;CHAR IN
	B	@COUT		;CHAR OUT
	B	@SELDSK		;SELECT A DISK DRIVE
	B	@RECAL	 	;RECALIBRATE DRIVES
	B	@SEEK		;SEEK THE TRACK IN R3
	B	@RDREC		;READ SELECTED SECTOR 
	B	@WRREC	 	;WRITE SELECTED SECTOR 
	B	@RDID		;READ TRACK ID ADDRESS
	B	@WBOOT		;PERFORM A WARM BOOT
	B	@RDTRK		;READ A TRACK OF DATA
	B	@WRTRK		;WRITE A TRACK OF DATA
	B	@BOOT		;PERFORM A COLD BOOT
;
;**********************************************************
;
;	DMA PARAMETER BLOCK DEFINITIONS
;	INDEXED DEPENDING ON READ(0), OR WRITE(1) COMMAND
;
;************************************************************
;
CMDTBL  STCR	*R8+,BYTEWIDE		;BYTE WIDE FDC DATA READ
	LDCR	*R8+,BYTEWIDE		;BYTE WIDE FDC DATA WRITE
;
;--REGISTERS IN INTERRUPT 3 WORKSPACE  
;
DMACMD	SET	2*R9+INTWP2	;CURRENT COMMAND
DMAADDR SET	2*R8+INTWP2	;REGISTER HOLDING SOURCE ADDRESS
DMAPORT SET	2*R12+INTWP2	;IO BASE REG I.E. DATAREG
;
;--IO	PARAMETER	BLOCK
;
STAT	WORD	0	 	;OPERATION STATUS
BYTESRD	WORD	0		;A DEBUGGING FEATURE FOR NUMBER OF BYTES READ
TRKSTAT	WORD	0		;VERIFIED TRACK STATUS
SECSTAT	WORD	0		;VERIFIED SECTOR STATUS
IOPTR	WORD	0		;IO BUFFER POINTER IN R8 OF DRQ INT
TRACK	WORD	-1	 	;CURRENT SELECTED DRIVE TRACK NO
TRKTAB	WORD	0,0		;DRIVE 1, 2 => ;HEAD POSITIONS FOR 2 DRIVES	
TYPTAB	WORD	0,0		;DRIVE 1, 2 => BIT 1 1=SD,0=DD;BIT 2 1=MINI=5.25, 0=MINI=3.5
SECTOR	WORD	0	 	;CURRENT SECTOR NO.
SIDE	WORD	0		;SIDE SELECT BIT
CMDTYP	WORD	0		;COMMAND TYPE
DSKTYP	WORD	00B		;CURRENT UNIT / DENSITY INDICATOR (USING TYPTAB ABOVE)
DRIVE	WORD	0		;CURRENT DRIVE
RDYCNT	WORD	0		;DRIVE READY COUNTER
MAXRWT	WORD	5		;NUMBER OF RETRIES ALLOWED
RWTRY	WORD	5
ERRTYP	WORD	0			;ERROR STAUTS FOR READ/WRITE ROUTINES
OPCOMP	WORD	0			;CLEARED WHEN IF DISK OPERATION COMPLETE
DRVRDY	WORD	0			;CLEARED WHEN DRIVE READY TIME OUT
SELCPY	BYTE	0			;COPY OF DATA IN SELECT/MUX OUTPUTS
		EVEN
INUSE	WORD	0
CRLF	BYTE	0DH,0AH,0
		EVEN
REDTRY	WORD	4			;NO OF RETRIES
;
;1797-FDC COMMANDS
;
RDCMD	EQU	10001000B 		;READ CMD
RIDCMD	EQU	11000000B	 	;READ ID 
WRCMD	EQU	10101000B 		;WRITE CMD
WTCMD   EQU	11110000B		;WRITE TRACK
RTCMD	EQU	11100000B		;READ TRACK
SEKCMD	EQU	00011100B 		;SEEK CMD
RSTCMD	EQU	00001100B	 	;RESTORE COMMAND
FINTCMD	EQU	11010000B		;FORCE INTERRUPT COMMAND
SICMD	EQU	01011100B		;STEP IN COMMAND
SOCMD	EQU	01111100B		;STEP OUT COMMAND
;
;--FDC 1797 IO REG LOCATIONS
;
FDC1797 EQU	8000H			;IO BASE REGISTER
STSREG	EQU	FDC1797+0 		;MAIN STATUS REG
CMDREG	EQU	FDC1797+0 		;COMMAND REGISTER 
TRKREG	EQU	FDC1797+2		;TRACK REGISTER
SECREG	EQU	FDC1797+4		;SECTOR REGISTER
DATREG	EQU	FDC1797+6		;DATA REGISTER
;
;
;--PORTS ETC.
;
SELMUX	EQU	0			;SELECT CONTROL PORT
TYPMUX	EQU	SELMUX + 2*5		;START AT BIT 5
BYTEWIDE 	EQU	2		;PARALLEL I/O DONE IN BYTES (UNIQUE TO 99105)
;
;
;COLD	START	ENTRY	POINT
;
;
	EVEN
XOPTAB	WORD	XOPWP0,XOP0,XOPWP1,XOP1,XOPWP2,XOP2,XOPWP3,XOP3
	WORD	XOPWP4,XOP4,XOPWP5,XOP5,XOPWP6,XOP6,XOPWP7,XOP7,XOPWP8,XOP8
	WORD	XOPWP9,XOP9,XOPWP10,XOP10,XOPWP11,XOP11
	WORD	XOPWP12,XOP12,XOPWP13,XOP13,XOPWP14,XOP14,0,0
;
INTTAB	WORD	INTWP2,INTDRQ,INTWP3,INTREQ	;FDC1797 INTERUPT VECTORS
	WORD	INTWP4,INTTIMER			;TIMER INTERRUPT
;
	EVEN

;
;	NOTE.  PROGRAMMES MUST CALL WITH THEIR WP POINTERS SET
;	THIS CALL IS USED TO SET UP MONITOR
;	CALLED USING BLWP @MONITOR
;
INIT	LIMI	0	 		;DISABLE
	LWPI	WORKSP			;USE MONITOR LOCAL WORKSPACE
	LI	R10,STACKP		;STACK FOR LOCAL MONITOR USE
	LI	R9,STACKL		;STACK LIMIT - ONLY ABOUT 64 WORDS
	
;
;************************************************************
;
;	SWTICH TO MONITOR XOP VECTORS RATHER THAN TIMON ROM
;	THIS MEANS THAT ALL PROGRAMMES THAT USE XOP WILL USE THE
;	THE XOP IMPLEMENTATIONS DEFINED IN MONITOR THAT IS HERE!
;
;************************************************************

	LI	R0,INTVEC		;SET UP INTERRUPT VECTORS
	LI	R1,INTTAB		;ONLY INT 2 TO 4 
INT1	NOP
	MOV	*R1+,*R0+
	MOV	*R1+,*R0+
	CI	R0,INTVEC+12
	JNE	INT1
	LI	R0,40H			;INITIALISE XOP-START AT XOP0
	LI	R1,XOPTAB
INIT2	NOP				;WRITE PROTECT
	MOV	*R1+,*R0+
	NOP				;WTRITE PROTECT
	MOV	*R1+,*R0+	
	CI	R0,80H			;FINISHED?
	JNE	INIT2			;NO
	JMP	WBOOT
;
;	WARM BOOT - CALLED FROM BDOS AND TIMON ONLY
;	THEREFORE NEED TO LOAD WP POINTERS
;	BUT MUST INITIALISE MONITOR BEFORE CALLING, I.E. BLWP @MONITOR
;
BOOT	LWPI	WORKSP			;USE MONITOR WP
	LI	R10,STACKP		;;STACK FOR LOCAL BIOS USE
	LI	R9,STACKL		;;STACK LIMIT - ONLY ABOUT 64 WORDS 	
	JMP 	BOOT0			;B 	@TIMON
	RSET
	LIMI	0			;DISABLE
	CLR	R0			;VECTOR LOCATION FOR BIOS
;	LI	R1,0460H		;BRANCH INSTRUCTION
;	LI	R2,WBOOT		;A CALL TO MONITOR WILL WARM BOOT
;	LI	R4,BDOS
;	MOV	R1,*R0+			;DO MONITOR VECTOR
;	MOV	R2,*R0+
;  	MOV	R1,*R0+			;DO BDOS VECTOR
;	MOV	R4,*R0
;
;---NOW TRY TO BOOT FROM TRACK 0 SECTOR 1
;
BOOT0	MESG	@BMSG2
	CLR	R2
	CALL	@SELDSK			;SELECT DRIVE A
	JNE	BOOT2
	CALL	@RECAL		 	;RECAL DRIVE A
	LI	R3,1			;BOOT SECTOR
	LI	R4,LOADER		;USE THIS AREA TO BOOT
	CALL	@RDREC
	JNE	BOOT2
	B	@LOADER			;BRANCH HERE TO LOAD THE SYSTEM
;
; --BOOT ERROR
;
BOOT2	MOV	R1,@STAT
	MESG	@BMSG1
	B	@TIMON
;
BMSG1	TEXT	'--Boot error'
	BYTE	0DH,0AH,0
	EVEN
BMSG2	TEXT	'--Booting....'
	BYTE	0DH,0AH,0
	EVEN
;
;	CLEAR THE DISK PARAMETERS
;
WBOOT	SETO	@TRACK			;INVALIDATE TRACK
	CLR	@SECTOR
	CLR	@DRIVE
	LI	R2,0			;SELECT BOOT DRIVE
	CALL	@SELDSK			;SELECT DISK
	CALL	@RECAL			;RECAL
	RTWP				;RETURN FROM BLWP 
;
;	B	@SHELL			;LET THERE BE LIFE 
;
;****************************
;
; CHAR IN (MSB	OF R1)
;
;*****************************	
CIN	READ	R1	 		;GET CHAR
	RET
;*******************************
;
;	CHAR OUT (MSB OF R2)
;
;********************************
;
COUT	CLR	R1
	MOVB	R2,R1	 		;COPY CHAR TO R1
	WRITE	R1	 		;OUTPUT IT
	RET	 
;
;******************************
;
;SELECT	THE	DRIVE	IN R2
;
;******************************
;
SELDSK	CI	R2,1			;MAXIMUM NUMBER IS 2
	JGT	SELRET
	CALL	@DRVSEL			;SELECT THE DRIVE
	CALL	@READY			;EMIT NEW SELECT BITS AND TEST READY
	JNE	SELRET
	MOV	R1,R1
	JNE	SELRET			;NOT READY
	MOV	@DRIVE,R3		;SAVE LAST UNIT
	SLA	R3,1			;TWO BYTES PER WORD
	MOV	R2,@DRIVE		;NEW UNIT
	MOV	@TRACK,@TRKTAB(R3)	;STORE PREVIOUS DRIVES TRACK POSITION
	MOV	@DSKTYP,R1
	ANDI	R1,00000011B
	MOV	R1,@TYPTAB(R3)		;STORE PREVIOUS DISK TYPE
	LI	PORT,TRKREG		
	SLA	R2,1			;MULTIPLY BY 2, IE TWO BYTES PER WORD
	MOV	@TRKTAB(R2),R1		;GET LAST KNOWN HEAD POSITION FOR NEW DRIVE
	MOV	R1,@TRACK		;SAVE THE DRIVE'S NEW POSITION AND
	SWPB	R1
	LDCR	R1,BYTEWIDE 		;OUTPUT TO THE 1797 FDC
	MOV	@DSKTYP,R1		;DENSITY BITS ETC
	ANDI	R1,11111100B		;MERGE IN NEW DENSITY CONTROL BIT
	SOC	@TYPTAB(R2),R1
	CALL	@SETDENS		;SET DENSITY CONTROL BIT
SELRET	BLWP	@SETTIMER		;SET DRIVE TIMER
	RET
;
;	OUTPUT SELECT BITS
;
DRVSEL	ANDI	R2,00000011B		;MAKE SURE IT'S IN RANGE	
	MOVB	@SELTAB(R2),@SELCPY	;STORE NEW STATE OF SELECT/MUX PORT
	RET
;
SELTAB	BYTE	00000001B		;BITS FOR UNIT # 0
	BYTE	00000010B
	BYTE	00000100B
	BYTE	00001000B
;
; TURN OFF ALL DRIVES
;
DESELECT LI	PORT,SELMUX
	CLR	R0
	LDCR	R0,5			;CLEAR DISKS
	RET

;
;	EMIT MUX BITS AND SEE IF DRIVE IS READY
;
READY	LI	R1,1
	MOV	R1,@INUSE		;SET DISK-ACTIVE FLAG
	LI	PORT,SELMUX		;SELECT PORT
	CLR	R1
	LDCR	R1,5			;CLEAR SELECT BITS FIRST
	LDCR	@SELCPY,5		;NEW SELECT BITS
	MOV	@TIMEOUT,R0
	CI	R0,1
	JNE	READY1
	CALL	@FORCE
	ANDI	R1,10000000B
	JNE	READY2
READY1	CALL	@WAITRDY
	CALL	@FORCE			;CLEAR CONTROLLER AND TEST DRIVE
	ANDI	R1,10000000B		;READY FLAG
READY2	MOV	R1,@STAT
	RET
;
;
FORCE	LI	R1,FINTCMD		;FORCE INTERRUPT COMMAND
	CALL	@EXCMD
	LI	PORT,STSREG		;GET RESULT BYTE AS NO INTERRUPT
	STCR	R1,BYTEWIDE		;HAS OCCURRED
	SRL	R1,8
	RET
;
;*****************************
;
;--RECAL IS JUST SEEK TO TRK ZERO (RECAL IS HANDLED THERE)
;
;*****************************
;
RECAL	LI	R3,0			;RECAL COMMAND
	SETO	@TRACK			;INVALIDATE TRACK SEEK WILL ZERO
	CALL	@SEEK			;TRACK REGISTER IS ZEROED
	ANDI	R1,10000001B
	RET
;
;*******************************
;
;READ ID FIELDS
;
;******************************
;
RDID	MOV	R4,@IOPTR
	CALL	@READY
	JNE	RDIDX
	LI	R2,RIDCMD
	CALL	@RDWRT			;READ ID RECORD INTO (R4)
	JNE	RDIDX			;EXIT IF DISK ERROR
	MOV	@IOPTR,R4
	AI	R4,6			;POINT TO 7TH BYTE AFTER ID RECORD
	MOV	@DSKTYP,*R4		;STORE DISK TYPE THERE
RDIDX	BLWP	@SETTIMER
	RET
;
;****************************
;
;READ A RECORD
; 	R3 HOLDS SECTOR
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
RDREC	MOV	R4,@IOPTR
	MOV	R3,@SECTOR
	CALL	@READY
	JNE	RDRECX			;EXIT IF DRIVE NOT READY
	LI	R2,RDCMD		;DO A READ COMMAND
	CALL	@RDWRT
RDRECX	BLWP	@SETTIMER
	RET				;BIND	*SP+ ;RET
;****************************
;
;READ A TRACK
; 	R3 NOT REQUIRED
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
RDTRK	MOV	R4,@IOPTR
	LI	R3,1		;DUMMY
	MOV	R3,@SECTOR
	CALL	@READY
	JNE	RDTRKX		;EXIT IF DRIVE NOT READY
	LI	R2,RTCMD		;DO A READ COMMAND
	CALL	@RDWRT
RDTRKX	BLWP	@SETTIMER
	RET			;BIND	*SP+ ;RET;
;
;****************************
;
;WRITE A TRACK
; 	R3 NOT REQUIRED
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
WRTRK	MOV	R4,@IOPTR
	MOV	R3,@TRACK
	CALL	@READY
	JNE	RDTRKX		;EXIT IF DRIVE NOT READY
	LI	R2,WTCMD		;DO A READ COMMAND
	CALL	@RDWRT
WRTRKX	BLWP	@SETTIMER
	RET			;BIND	*SP+ ;RET;
	;
;******************************
;
;WRITE A RECORD
; 	R3 HOLDS SECTOR
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
WRREC	MOV	R4,@IOPTR
	MOV	R3,@SECTOR
	CALL	@READY
	JNE	WRRECX
	LI	R2,WRCMD
	CALL	@RDWRT
WRRECX	BLWP	@SETTIMER
	RET
;
; SECTOR TRANSLATE (NOT NEEDED ANYMORE MAY 2010)
; SO  JUST RETURN
;
SECTRAN	RET			;NOT NEEDED WITH IBM FORMATS
;	ANDI	R3,000FH
;	DEC	R3		; 0 -> 8
;	AI	R3,SETTBL
;	MOVB 	*R3,R0
;	MOV	R0,R3
;	SRL	R3,8
;	RET
;SETTBL	BYTE	1,4,7,2,5,8,3,6,9	;1,4,7,9,2,5,8,3,6
;	EVEN
;
;
;********************************
;
;	COMMON READ AND WRITE ROUTINE (RDWRT)
;	ENTER WITH 
;		R4 -> IO BUFFER
;		R3 -> SECTOR
;		R2 -> COMMAND TYPE
;
;	ASSUME THE CORRECT TRACK IS UNDER THE DISK HEAD
;
;	TREAT DRQINT AS A PSUEDO DMA CHANNEL
;	BY LOADING THE PORT REGISTER(R12) WITH THE
;	I/O ADDRESS AND THE TYPE OF OPERATION I.E. READ/WRITE
;	THERE IS NO COUNT AS I RELY ON AN INTERRUPT FROM THE
;	FDC1797 TO TERMINATE THE TRANSFER.
;
;*********************************
;
RDWRT	;MOV	R4,@IOPTR		;SAVE DISK I/O DATA POINTER
	CALL	@SECTRAN		;SECTOR TRANSLATE ALL EXCEPT SECTOR 1
	;MOV	R3,@SECTOR		;SAVE SECTOR
	MOV	R2,@CMDTYP		;SAVE READ/WRITE/READID COMMAND
	MOV	@MAXRWT,@RWTRY		;SET READ/WRITE RETRY
RDWRT0	MOV	@SECTOR,R3
	LI	PORT,SECREG		;FDC SECTOR REGISTER
	SWPB	R3
	LDCR	R3,BYTEWIDE
;
;	SET UP PSUEDO DMA CHANNEL
;
	CLR	R3			;INDEX POINTER
	LI	R0,DATREG		;FDC REG WHERE DATA IS
	MOV	R0,@DMAPORT
	MOV	@IOPTR,@DMAADDR		;DMA TRANSFER ADDRESS
	MOV	@CMDTYP,R1
	CI	R1,WRCMD		;WRITE COMMAND ?
	JEQ	RDWRT1			;YES
	CI	R1,WTCMD		;WRITE COMMAND ?
	JEQ	RDWRT1			;YES
	MOV	@CMDTBL(R3),@DMACMD	;EXECUTE A READ COMMAND (STCR)
	JMP	RDWRT2
RDWRT1	INCT	R3
	MOV	@CMDTBL(R3),@DMACMD	;EXECUTE A WRITE COMMAND (LDCR)
;
;
;--MERGE SIDE BIT BEFORE COMMAND IS EXECUTED
;
RDWRT2	CI	R1,RIDCMD		;IF ID CMD DON'T NEED TO MERGE
	JEQ	RDWRT5
	MOV	@SIDE,R0		;GET SIDE BIT
	SLA	R0,1
	SOC	R0,R1			;OR IN SIDE BIT INTO COMMAND BYTE
RDWRT5	CALL	@EXCMD
	ANDI	R1,11011111B		;MASK READY/WRITEPROTECT/RNF/CRC/OVERRUN/DRQ/BUSY
	JEQ	RDWRT4			;RETURN IN NO DISK IO ERROR
	MOV	R1,@ERRTYP
	CALL	@RECOVER		;DO READ/WRITE ERROR RECOVERY
	JNE	RDWRT3			;DON'T RETRY IF UN-RECOVERABLE ERROR
	DEC	@RWTRY			;ELSE DECREMENT AND KEEP TRYING UNTIL 0
	JNE	RDWRT0
RDWRT3	MOV	@ERRTYP,R1
	B	@IOERR
RDWRT4	RET
;
;***************************************
;
;	ATTEMPT TO RECOVER FROM A READ WRITE
;	ERROR
;
;****************************************
;
RECOVER	MOV	R1,R2			;COPY ERROR CODE TO R2
	ANDI	R2,10000111B		;ISOLATE REAY/OVERRUN/DRQ/BUSY ERRORS
	JEQ	RECOV1			;JUMP IF NONE OF THOSE SET
	MOV	R1,R2
	CALL	@FORCE			;CLEAR ERROR FLAGS IN 1797
	MOV	R2,R1
RECOV0	RET
;
;	ARRIVE HERE IF CRC OR RNF ERROR
;
RECOV1	MOV	R1,R2
	ANDI	R2,00010000B	;SECTOR ID NOT FOUND
	JEQ	RECOV2
	ANDI	R2,00100000B	;RNF ERROR
	JEQ	RECOV3
	RET			;PROCESS ID NOT FOUND ERROR
;
;	ARRIVE HERE ON BAD CRC IN DATA OR ID FIELD
;
RECOV2	C	@RWTRY,@MAXRWT	;CHECK FOR FIRST TIME
	JEQ	RECOV0
	LI	R1,SICMD		;STEP BACK AND FORTH
	CALL	@EXCMD
	LI	R1,SICMD		;STEP IN TWO TRACKS THEN BACK
	CALL	@EXCMD
	LI	R1,SOCMD
	CALL	@EXCMD
	LI	R1,SOCMD
	CALL	@EXCMD
	RET				;RETURN WITH STATUS IN R1
;
;	ARRIVE HERE IF RNF ERROR
;
RECOV3 	PUSH	@DSKTYP			;SAVE DENSITY CONTROL BYTE
	CALL	@VERIFY			;TRACK VERIFY USING READ - ID
	POP	R3			;KEEP PREVIOUS DENSITY BYTE HERE
	JEQ	RECOV4			;RETURN IF NO ID MARK FOUND
	RET
;
RECOV4	C	@DSKTYP,R3		;SEE IF DENSITY WAS CHANGED BY 'VERIFY'
	JEQ	RECOV5			;AND EXIT WITH RNF IF NOT
	CLR	R1
	MOV	R1,R1			;CLEAR R1 TO INDICATE A RETRY SHOULD BE
	RET				;DONE NOW THAT DENSITY IS RIGHT
;
RECOV5	LI	R1,00010000B
	MOV	R1,R1			;INDICATE ERROR DUE TO NON-EXISTENT
	RET				; SECTOR OR INDETERMINATE TRACK
;
; OBSOLETE NOW AS DENSITY IS FIXED
; DO NOTHING
;
VERIFY	CLR	R0
	RET
;	LI	R1,RIDCMD
;	CALL	@EXCMD			;READ NEXT ID-MARK TO VERIFY SEEK
;	ANDI	R1,10011001B
;	JEQ	VERFY2			;JUMP IF ID MARK READ SUCCESSFULLY
;	CALL	@FLIPDENS		;ELSE SWITCH DISK DENSITY CONFIGURATION
;	LI	R1,RIDCMD
;	CALL	@EXCMD			;TRY AGAIN		
;	ANDI	R1,10011001B
;VERFY2	MOV	R1,R5			;SAVE STATUS OF READ-ID COMMAND
;	CALL	@FORCE			;CLEAR OVERRUN AND DRQ BITS IN 1797
;	MOV	R5,R1
;	JNE	VERFY3			;RETURN IF ID MARK WAS FOUND
;	RET
;VERFY3	CALL	@FLIPDENS		;ELSE GO BACK TO ORIGINAL DENSITY
;	MOV	R5,R1			;RETURN WITH ERROR INDICATED
;	RET
;
;********************************
;
;INTIALISE	INT.VECTORS	ETC	
;
;*******************************
;
INTSYS	RET
;
;********************************
;
;RESET	FDC
;
;********************************
;
RSET	RET
;
;
;*******************************************
;
; 	SET THE TIME OUT TIMER
;
SETTIMER 
	WORD	INTWP4,SETTIMER+4
	LI	PORT,0080H
	SBZ	20			;RESET INTERRUPT
	LI	R8,200			; 200 X 16MS = 3.0SEC
	MOV	R8,@TIMEOUT
	SBZ	14
	SBO	13			;LOAD INTERVAL TIMER ONLY
	LDCR	@INTLV2,8
	SBO	20			;ENABLE INTERRUPT
	RTWP
;
INTLV2	BYTE	255			;16.0 MILLISECONDS
	EVEN
;
;ALLOW TIME FOR USER TO INSERT DISC (IN FUTURE MAY INCREASE THE TIMEOUT)
;
WAITRDY	CALL	@FORCE
	LI	PORT,STSREG
	SETO	@DRVRDY		;ALLOWS US TO TIMEOUT
;
WAITRDY1
	STCR	R0,BYTEWIDE
	ANDI	R0,8000H
	JEQ	WAITRDY2
;
;	WAIT FOR 32uS FOR DRIVE TO BECOME READY
;
	DEC	@DRVRDY
	JNE	WAITRDY1
WAITRDY2
	RET
;
;******************************************
;
;	SET DENSITY BIT 
;
;******************************************
;
SETDENS	MOV	R1,@DSKTYP
	LI	PORT,TYPMUX
	SWPB	R1
	LDCR	R1,2		;OUTPUT CONTROL BITS
	CLR	R1
	MOV	R1,R1
	RET
;
;;*******************************************
;
;	SEEK TO THE TRACK NUMBER HELD IN R3
;
;	DRIVE # IS IN DRIVE
;
;********************************************
;
SEEK	CALL	@READY		;SEE IF DRIVE IS READY FIRST
	JNE	SEEK3		;ERROR CONDITION IN OPSTAT
	CLR	@SIDE		;ASSUME SIDE 0		
	TCMB	R3,0		;TEST AND CLEAR MSB
	JNE	SEEK0		;SIDE 0
	INC	@SIDE		;SIDE 1
SEEK0	C	R3,@TRACK	;ARE WE ALREADY THERE ?
	JEQ	SEEK3		;STAT WILL SHOW OKAY
	MOV	@TRACK,R1		
	CI	R1,-1		;IF NOT KNOWN TRACK RECAL DRIVE
	JNE	SEEK2
	LI	R1,RSTCMD+3
	CALL	@EXCMD		;EXECUTE RESTORE COMMAND
	LI	R0,00000100B	;TRK00 BIT
	XOR	R0,R1		;MAKE TRK00 BIT TRUE
	ANDI	R1,10000101B	;NOT FOUND AND NOT READY BITS
	JNE	SEEK3		;IF OK SEEK REQUIRED TRACK
SEEK2	MOV	R3,@TRACK
	LI	PORT,DATREG		;PROGRAM FDC TO SEEK TRACK IN DATA REG
	SWPB	R3
	LDCR	R3,BYTEWIDE		;OUTPUT TO FDC PORT
	LI	R1,SEKCMD
	CALL	@EXCMD
	ANDI	R1,10010000B	;NOT FOUND & NOT READY ERROR
	JEQ	SEEK3
	SETO	@TRACK
SEEK3	MOV	R1,R1		;INDICATE RESULT TYPE
	RET
;
;	EXECUTE THE COMMAND IN REGISTER R1
;
;BYTEWIDE EQU 2				;WR 12 not altered	
;
EXCMD	LIMI	3			;DISABLE INTERRUPTS
	LI	PORT,CMDREG
	SWPB	R1
	LDCR	R1,BYTEWIDE		;OUTPUT CONTROLLER COMMAND
;	LIMI	3			;ENABLE FDC INTERRUPTS ONLY
	LI	R0, 40			;DELAY AROUND 60uS BEFORE READING STATUS
EXCMD1	DEC	R0
	JNE	EXCMD1
	CI	R1,FINTCMD*256		;IF FORCE INTERRUPT EXIT
	JEQ	EXCMD3
;	CI	R1,RDCMD*256
;	JNE	EXT
;
;--WHEN THE FDC COMPLETION INTERRUPT ROUTINE IS ENTERED THIS TEMPORARY
;  HALT INSTRUCTION WILL BE BYPASSED
;
	SETO	@OPCOMP
EXCMD4A	MOV	@OPCOMP, R1		;TIMEOUT WILL ALSO CLEAR THIS
	JNE	EXCMD4A			;USE FDCINT TO BUMP PAST THIS ADDRESS
	MOV	@STAT,R1		;STATUS REGISTER RESULT
EXCMD3	LIMI	4			;THIS ENABLES TIMER INTERRUPT
	RET
;
;************************************************
;
;WRITE	ERROR	MESSAGE
;
;**************************************************
;
IOERR	MESG	@ERRMSG	
	WHEX    R1	 		;O/P TYPE
	MESG	@DRVMSG			;DISK MESSAGE
	WHEX	@DRIVE			;DRV #
	MESG	@TRKMSG			;TRACK #
	WHEX	@TRACK
	MESG	@SECTMSG	 	;SECTOR MESSAGE
	WHEX	@SECTOR			;SECTOR #
	RET
;	B	@TIMON			;FATAL 
;
;
;******************************
;
;	MAIN INTERRUPT ROUTINES
;
;********************************
;
INTREQ 	LI	PORT,STSREG
	CLR	R8
	STCR	R8,BYTEWIDE
	SWPB	R8
	MOV	R8,@STAT		;SHOW RESULT OF OPERATION
	JMP	INTREQ1
	
;CHECK TRACK REGISTER
	LI	PORT,TRKREG
	CLR	R8
	STCR	R8,BYTEWIDE
	SWPB	R8
	MOV	R8,@TRKSTAT
;CHECK SECTOR REGISTER
	LI	PORT,SECREG
	CLR	R8
	STCR	R8,BYTEWIDE
	SWPB	R8
	MOV	R8,@SECSTAT	
INTREQ1	CLR	@OPCOMP		;SHOW THAT THE INTERRUPT WAS EXECUTED
	RTWP
;
;***********************************
;
;	THIS INTERRUPT SIMULATES DMA CONTROL
;	ORGANISED AS FOLLOWS:
;
;	R9 HOLDS CURRENT COMMAND I.E. STCR OR LDCR
;	R8 HOLDS THE CURRENT DMA ADDRESS.
; 	R12 HOLDS THE CURRENT IO PORT - GENERALLY DATREG
;
INTDRQ	X	R9		;EXECUTE THE COMMAND SPECIFIED BY RDWRT
	RTWP
;
;*********************************************************************
;
;	THIS INTERRUPT IS CONTROLED BY THE TIMER
;
;**********************************************************************
;
TIMEOUT	WORD 	1		;N * 16MS DURATION
INTTIMER 	
	LI	PORT,0080H
	TB	25
	JNE	TIME2
	SBO	20		;RESET INTERRUPT
	DEC	@TIMEOUT
	JNE	TIME2
	INC	@TIMEOUT
	SBZ	20		;DISABLE TIMER
	LI	PORT,SELMUX
	CLR	R8
	LDCR	R8,5		;CLEAR DISKS
TIME2	RTWP
;
;***********************************************************************
;
;	MESSAGES
;
;************************************************************************
;
ERRMSG	BYTE	0DH,0AH,20H
	TEXT	'FDC error type: '
	BYTE	0
STKMSG	BYTE	0DH,0AH,20H
	TEXT	'Stack overflow at: '
	BYTE	0
DRVMSG	TEXT	' Drive: '
	BYTE	0
TRKMSG	TEXT	' Track: '
	BYTE	0
SECTMSG	TEXT	' Sector: '
	BYTE	0
;
;***************************************************************************
;
;	ALL XOP's AND WORKSPACES ARE DEFINED IN THIS SECTION AND ARE USED BY ALL PROGRAMMES
;	THAT INTERACT WITH THE MONITOR ROUTINES
;
;	NOTES.
;		1. ALL INTWP'S AND XOPWP'S OVERLAP AND SO ANY INT OR XOP
;	      	   FUNCTIONS MAY ONLY USE REGISTERS R8-R10. REGISTERS R11
;	      	   TO R15 ARE RESERVED FOR XOP & INT LINKAGES.
;
;		2. THE XOP WORKSPACES ARE JUST FOR MANAGING THE STACK AND CONTEXT
;		   CALLS THE ORIGINAL WP IS PRESERVED AFTER THE CALL, WHICH MEANS
;		   THAT CALLING ROUTINES SHARE THE SAME REGISTERS.
;
;		3. EVEN THOUGH R9 & R10 ARE GENERALLY USED AS STACK REGISTERS
;		   THIS DOES NOT APPLY IN INTERRUPT WORKSPACE WHERE THEY CAN'T
;		   BE USED FOR THAT PURPOSE - SIMPLY BECAUSE THE STACK POINTER 
;		   IS NOT PASSED TO THE NEW WORKSPACE.  THEY CAN BE COPIED USING
;		   THE R13 INDEX IF NEEDED AS R13 POINTS TO THE CALLING ROUTINE'S WORKSPACE
;
;*****************************************************************************
;
	EVEN
INTWP0	EQU	$ + 0			;INTERRUPT WORKSPACE
INTWP1	EQU	INTWP0+16		;ONLY 7 ALLOWED
INTWP2	EQU	INTWP1+16
INTWP3	EQU	INTWP2+16
INTWP4	EQU	INTWP3+16
INTWP5	EQU	INTWP4+16
INTWP6	EQU	INTWP5+16
INTWP7	EQU	INTWP6+16
;
;    NOW XOP'S
;
XOPWP0	EQU	INTWP7+16
XOPWP1	EQU	XOPWP0+16
XOPWP2	EQU	XOPWP1+16
XOPWP3	EQU	XOPWP2+16
XOPWP4	EQU	XOPWP3+16
XOPWP5	EQU	XOPWP4+16
XOPWP6	EQU	XOPWP5+16
XOPWP7	EQU	XOPWP6+16
XOPWP8	EQU	XOPWP7+16
XOPWP9	EQU	XOPWP8+16
XOPWP10 EQU	XOPWP9+16
XOPWP11	EQU	XOPWP10+16
XOPWP12 EQU	XOPWP11+16
XOPWP13 EQU	XOPWP12+16
XOPWP14 EQU	XOPWP13+16
XOPWP15 EQU	XOPWP14+16
;
	AORG	XOPWP15+32

;
;
;	DEFINE ALL THE XOP ROUTINES
;
XOP0	RTWP
XOP1	RTWP
XOP2	RTWP
XOP3	RTWP
XOP15	RTWP
;
CRUBAS	EQU	80H			;TMS9902 CRU BASE
;
;**********************************************
; PUSH REGISTERS R0 to RN ONTO THE STACK
;*********************************************
;
XOP4	
	MOV	R13,R8			;GET THE EFFECTIVE ADDRESS OF CALLING WORKSPACE
	MOV	@2*R10(R13),R10		;GET SYSTEM STACK POINTER
XOP4A	DECT	R10			;DECREMENT STACK POINTER
;	C	R10,@2*R9(R13)		;CHECK FOR OVERFLOW
;	JLE	STACKERR
	MOV	*R8+,*R10
	C	R8,R11			;KEEP PUSHING REGISTERS (R11 HOLDS EFFECTIVE ADDRESS OF REGISTER RN)
	JLE	XOP4A	
	MOV	R10,@2*R10(R13)		;UPDATE THE STACK POINTER 
	RTWP
;
;***********************************************
; POPS REGISTERS R0 to RN OFF THE STACK
;************************************************
;
XOP5	MOV	@2*R10(R13),R10		;GET STACK POINTER
XOP5A	MOV	*R10+,*R11		;GET FIRST REGISTER
	DECT	R11			;DECT TWO EFFECTIVE ADDRESS, IE RN
	C	R11,R13			;COMPARE AGAINST WORKSPACE TOP ADDRESS IE R0
	JHE	XOP5A
	MOV	R10,@2*R10(R13)
	RTWP
;
;************************************************
;	CALL	SUBROUTINE
;	CALLING METHOD:   CALL SUBROUTINE_ADDRESS
;*************************************************
;
XOP6	MOV	@2*R10(R13),R10 	;GET STACK POINTER
	DECT	R10
;	C	R10,@2*R9(R13)		;CHECK FOR STACK OVERFLOW
;	JLE	STACKERR		;O/P STACK OVERFLOW MESSAGE
	MOV	R14,*R10		;PUSH SAVED PC ONTO STACH
;	ANDI	R14,1			;CHECK FOR ODD
;	JNE    	ODDMSG
	MOV	R11,R14			;MOVE EA INTO R14 FOR CALL
	MOV	R10,@2*R10(R13)		;UPDATE STACK POINTER
	RTWP				;NOTE WE ARE NOW USING THE ORIGINAL WP
;
;============================================
;	SUBROUTINE RETURN
;	CALLING METHOD:	RET
;============================================
;
XOP7	MOV	@2*R10(R13),R10		;GET STACK POINTER
	MOV	*R10+,R14		;MOVE EA INTO R14 FOR CALL 
	MOV	R10,@2*R10(R13)		;GET UPDATED STACK POINTER
	RTWP				;RETURN
;
;*************************************************
;	PUSH DATA/REGISTER ONTO THE STACK
;	USES CALLER'S WP AND STACK POINTERS
;*************************************************
;
XOP8	;MOV	@FREEMEM,@2*R9(R13)	;UPDATE FREE MEMORY POINTER IE STACK LIMIT
	MOV	@2*R10(R13),R10
	DECT	R10
;	C	R10,@2*R9(R13)		;CHECK FOR OVERFLOW
;	JLE	STACKERR
	MOV	*R11,*R10
	MOV	R10,@2*R10(R13)
	RTWP
;
;	POP DATA/REGISTER OFF STACK
;
XOP9	MOV	@2*R10(R13),R10
	MOV	*R10+,*R11
	MOV	R10,@2*R10(R13)
	RTWP
;
;=====================================================
;	WRITE A HEX CHARACTER
;
;	CALLING METHOD:   WHEX RN
;
;	FUNCTION: WRITE CONTENTS OF RN AS 4 HEX DIGITS 
;========================================================
;
XOP10	MOV	*R11,R12		;GET VALUE
	LI 	R9,4			;SET COUNTER TO 4 DIGITS
;
XOP10A	MOV	R12,R8			;MOVE 4 DIGITS INTO R8R 	
	SRL	R8,12			;ISOLATE HEX DIGIT
	SLA	R8,8			;BYTE ALIGN1
	CI	R8,0900H		;IS THIS NUMERIC
	JLE	XOP10B			;YES
	AI	R8,0700H		;ALPHA ADJUST
;
XOP10B	AI	R8,'0'*256		;NUMERIC TO ASCII
	WRITE	R8			;O/P THE HEX DIGIT
	SRC	R12,12			;ALIGN NEXT DIGIT
	DEC	R9			;IF FINISHED EXIT
	JNE	XOP10A
	RTWP
;
;===========================================================
;	READ IN A 16 BIT HEX CHARACTER
;
;	CALL:   RHEX RN
;
;	FUNCTION: READ  CONTENTS INTO  RN AS 4 HEX DIGITS 
;============================================================
;
XOP11	CLR	R12			;CLEAR ACCUMULATOR
XOP11A	READ	R10			;GET AN INPUT CHARACTER
	WRITE	R10			;ECHO THE CHARACTER
;
;	CHECK FOR VALID HEX INPUT
;
XOP11B	CI	R10,'0'*256		;BELOW MIN NUMERIC ?
	JL	NOTHEX			;IF YES, JUMP
	CI	R10,'9'*256		;ABOVE MAX NUMERIC ?
	JLE	GOTONE			;IF NO, JUMP
	CI	R10,'A'*256		;BELOW MIN ALPHA ?
	JL	NOTHEX			;IF YES JUMP
	CI	R10,'F'*256		;ABOVE MAX ALPHA ?
	JH	NOTHEX			;IF YES, JUMP
	AI	R10,0900H		;ALPHA ADJUST
GOTONE	SLA	R10,4			;ISOLATE DIGIT
	SRL	R10,12			;WORD ALIGN DIGIT
;
; DIGIT TO ACCUMULATOR
;
	SLA	R12,4		;MAKE ROOM FOR NEW DIGIT
	A	R10,R12		;ADD NEW DIGIT IN
	JMP	XOP11A		;GO GET NEXT DIGIT
NOTHEX	MOV	R12,*R11		;RETURN THE VALUE
	RTWP
;
;==================================================
;	WRITE A CHARACTER
;==================================================
;
XOP12	LI	R12,CRUBAS
	SBO	16
XOP12A	TB	22
	JNE	XOP12A
	LDCR	*R11,8
	SBZ	16
	RTWP
;
;====================================================
;	READ CHARACTER INTO LEFT BYTE (MSB)
;====================================================
;
XOP13	LI	R12,CRUBAS
XOP13A	TB	21		;RECEIVE BUFFER REG FULL ?
	JNE	XOP13A		;NO
	CLR	*R11
	STCR	*R11,8
	SBZ	18		;SHOW WE RECEIVED CHARACTER
	RTWP
;
;
;	OUTPUT A NULL TERMINATED STRING
;
XOP14	MOVB	*R11+,R12	;GET THE CHARACTER
	JEQ	XOP14A		;IF ZERO EXAT
	WRITE	R12
	JMP	XOP14		;RETURN
XOP14A	RTWP
;
;====================================================
;	STACK OVERFLOW HANDLER
;====================================================
;
STACKERR MESG	@STKMSG
	WHEX	@2*R9(R13)
	WHEX	R10
	B	@TIMON		;FATAL ERROR
;
MSG1 	BYTE 	0DH,0AH
	TEXT 	'ODD CALL FROM: '
	BYTE 	0
MSG2	TEXT 	' TO ADDR: '
	BYTE 	0
MSG3    TEXT 	' WP = '
	BYTE 	0
 	EVEN
PLUS	TEXT	'+'
	BYTE	0
DOT	TEXT	'.'
	BYTE	0
	EVEN
;
ODDMSG  MESG	@MSG1
 	WHEX	*R10		;CALLING ROUTINE
	MESG 	@MSG2
	WHEX	R11
	MESG	@MSG3
	WHEX	R15
	B	@TIMON
;
; END OF PROGRAMME
;

	EVEN
WORKSP	BSS	32	;MONITOR WORKSPACE
	END
	
	