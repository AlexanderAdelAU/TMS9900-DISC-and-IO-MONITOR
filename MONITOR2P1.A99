;
;---MONITOR AND FDC INTERFACE ROUTINES for the TI99000 SBC
;
;	The monitor routines are called from a DOS or other 
;	programme to perform Console I/O and Disc I/O similar
;	to a BIOS.
;
;	Version 2.0	14th May 2020 - The year of the Corona Virus
;
;   Written by Alex Cameron
;
R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
R7	EQU	7
R8	EQU	8
R9	EQU	9			;Use to index workspace pointer not stack overflow
;SL	EQU	R9			;STACK LIMIT
R10	EQU	10
;SP	EQU	R10			;STACK POINTER
R11	EQU	11
R12	EQU	12
PORT	EQU	R12			;IO BASE
R13	EQU	13
R14	EQU	14
R15	EQU	15
ST	EQU	15
;
;***************************************************
;
;	DEFINE SOME XOP'S
;
;****************************************************
;
	DXOP	PUSHREG,4	;PUSH RANGE OF REGISTERS TO STACH
	DXOP	POPREG,5	
	DXOP	CALL,6
	DXOP	RET,7
	DXOP	PUSH,8		;PUSH SINGLE REGISTER
	DXOP	POP,9
	DXOP	WHEX,10		;WRITE OUT A 16 BIT HEX VALUE
	DXOP	RHEX,11		;READ IN A 16 BIT HEX VALUE
	DXOP	WRITE,12		;WRITE CHAR IN MSB
	DXOP	READ,13		;READ CHAR IN MSB
	DXOP	MESG,14		;OUTPUT NULL TERMINATED MESSAGE
	DXOP	DEBUG,15
;
; SOME EQUATES
;
TIMON	EQU	0F000H		;GO TO TIMON UNDER WORST CASE CONDITIONS
SHELL	EQU	0CA00H		;ADDRESS OF SHELL
MONORG	EQU	0E600H		;ORIGIN FOR THIS MONITOR
STACKP	EQU	MONORG - 2
BOOT_TWP:	EQU	STACKP -32		;THIS IS BOOT TEMPORARY WORKSAPCE
	BSS	32	;MONITOR WORKSPACE
INTVEC	EQU	08H
LOADER	EQU	0C600H 		; THIS IS THE LOADER ADDRESS
;
;NOTE DOS IS NOT KNOWN TO MONITOR.
;

;
; LOCATE THE MONITOR IN MEMORY
;
	AORG	MONORG
;
;************************************************************************************
;
;	NOTE ALL PROGRAMMES MUST SET THE WORSPACE
;	POINTERS AND STACKS BEFORE CALLING
;
;	NOTE THE FIRST VECTOR BLWP - CALLED ONCE TO INITIALISE MONITOR
;
;*************************************************************************************
;
ENTRY	WORD	WORKSP		;THIS IS MONITOR WORKSAPCE
	WORD	INIT		;INITIALISE ALL XOP, INTERRUPT AND ENTRY VECTORS
BOOT_ADDR:	B	@BOOT		;PERFORM A COLD BOOT - POS IN TABLE HELPS DEBUGGING
	B	@CIN		;CHAR IN
	B	@COUT		;CHAR OUT
	B	@SELDSK		;SELECT A DISK DRIVE
	B	@RECAL	 	;RECALIBRATE DRIVES
	B	@SEEK		;SEEK THE TRACK IN R3
	B	@RDREC		;READ SELECTED SECTOR 
	B	@WRREC	 	;WRITE SELECTED SECTOR 
	B	@RDID		;READ TRACK ID ADDRESS
	B	@WBOOT		;PERFORM A WARM BOOT
	B	@RDTRK		;READ A TRACK OF DATA
	B	@WRTRK		;WRITE A TRACK OF DATA

;
;**********************************************************
;
;	DMA PARAMETER BLOCK DEFINITIONS
;	INDEXED DEPENDING ON READ(0), OR WRITE(1) COMMAND
;
;************************************************************
;
CMDTBL:	STCR	*R8+,BYTEWIDE		;BYTE WIDE FDC DATA READ
	LDCR	*R8+,BYTEWIDE		;BYTE WIDE FDC DATA WRITE
;
;--REGISTERS IN INTERRUPT 3 WORKSPACE  
;
DMACMD	SET	2*R9+INTWP2	;CURRENT COMMAND
DMAADDR 	SET	2*R8+INTWP2	;REGISTER HOLDING SOURCE ADDRESS
DMAPORT	SET	2*R12+INTWP2	;IO BASE REG I.E. DATAREG
;
;--IO	PARAMETER	BLOCK
;
FDCSTATUS	WORD	0	 	;OPERATION STATUS
BYTESRD	WORD	0		;A DEBUGGING FEATURE FOR NUMBER OF BYTES READ
TRKSTAT	WORD	0		;VERIFIED TRACK STATUS
SECSTAT	WORD	0		;VERIFIED SECTOR STATUS
IOPTR	WORD	0		;IO BUFFER POINTER IN R8 OF DRQ INT
TRACK	WORD	-1	 	;CURRENT SELECTED DRIVE TRACK NO
TRKTAB	WORD	0,0		;DRIVE 1, 2 => ;HEAD POSITIONS FOR 2 DRIVES	
TYPTAB	WORD	0,0		;DRIVE 1, 2 => BIT 1 1=SD,0=DD;BIT 2 1=MINI=5.25, 0=MINI=3.5
SECTOR	WORD	0	 	;CURRENT SECTOR NO.
SIDE	WORD	0		;SIDE SELECT BIT
CMDTYP	WORD	0		;COMMAND TYPE
DSKTYP	WORD	00B		;CURRENT UNIT / DENSITY INDICATOR (USING TYPTAB ABOVE)
DRIVE	WORD	0		;CURRENT DRIVE
FNDTRY:	WORD	7		;FIND TRACK RETRY COUNT
MAXRWT	WORD	5		;NUMBER OF RETRIES ALLOWED
RWTRY	WORD	5
ERRTYP	WORD	0			;ERROR STAUTS FOR READ/WRITE ROUTINES
OPCOMP	WORD	0			;CLEARED WHEN IF DISK OPERATION COMPLETE
DRVRDY	WORD	0			;CLEARED WHEN DRIVE READY TIME OUT
SELCPY	BYTE	0			;COPY OF DATA IN SELECT/MUX OUTPUTS
		EVEN
INUSE	WORD	0
CRLF	BYTE	0DH,0AH,0
		EVEN
REDTRY	WORD	4			;NO OF RETRIES
;
;1797-FDC COMMANDS
;
RDCMD:	EQU	10001000B 		;READ CMD
RIDCMD:	EQU	11000000B	 	;READ ID
WRCMD:	EQU	10101000B 		;WRITE CMD
WTCMD:	EQU	11110000B		;WRITE TRACK
RTCMD:	EQU	11100000B		;READ TRACK
SEKCMD:	EQU	00011100B 		;SEEK CMD
RSTCMD:	EQU	00001100B	 	;RESTORE COMMAND
FINTCMD:	EQU	11010000B		;FORCE INTERRUPT COMMAND
SICMD:	EQU	01011100B		;STEP IN COMMAND
SOCMD:	EQU	01111100B		;STEP OUT COMMAND
;
;--FDC 1797 IO REG LOCATIONS
;
FDC1797:	EQU	8000H		;IO BASE REGISTER- BYTE TRANSFER WITH MSB SET
STSREG:	EQU	FDC1797+0 		;MAIN STATUS REG
CMDREG:	EQU	FDC1797+0 		;COMMAND REGISTER
TRKREG:	EQU	FDC1797+2		;TRACK REGISTER
SECREG:	EQU	FDC1797+4		;SECTOR REGISTER
DATREG:	EQU	FDC1797+6		;DATA REGISTER
;
;
;--PORTS ETC.
;
SELMUX:	EQU	0		;SELECT CONTROL PORT
TYPMUX:	EQU	SELMUX + 2*5	;START AT BIT 5
BYTEWIDE:	EQU	2		;PARALLEL I/O DONE IN BYTES (UNIQUE TO 99105)
;
;
;COLD	START	ENTRY	POINT
;
;
	EVEN
XOPTAB	WORD	XOPWP0,XOP0,XOPWP1,XOP1,XOPWP2,XOP2,XOPWP3,XOP3
	WORD	XOPWP4,XOP4,XOPWP5,XOP5,XOPWP6,XOP6,XOPWP7,XOP7,XOPWP8,XOP8
	WORD	XOPWP9,XOP9,XOPWP10,XOP10,XOPWP11,XOP11
	WORD	XOPWP12,XOP12,XOPWP13,XOP13,XOPWP14,XOP14,XOPWP15,XOP15
;
INTTAB	WORD	INTWP2,INTDRQ,INTWP3,INTREQ	;FDC1797 INTERUPT VECTORS
	WORD	INTWP4,INTTIMER		;TIMER INTERRUPT
;
	EVEN

;
;	NOTE.  PROGRAMMES MUST CALL WITH THEIR WP POINTERS SET
;	THIS CALL IS USED TO SET UP MONITOR
;	CALLED USING BLWP @MONITOR
;
INIT:	LIMI	0	 		;DISABLE
	LWPI	WORKSP			;USE MONITOR LOCAL WORKSPACE
	LI	R10,STACKP			;STACK FOR LOCAL MONITOR USE
;
;************************************************************
;
;	SWTICH TO MONITOR XOP VECTORS RATHER THAN TIMON ROM
;	THIS MEANS THAT ALL PROGRAMMES THAT USE XOP WILL USE THE
;	THE XOP IMPLEMENTATIONS DEFINED IN MONITOR THAT IS HERE!
;
;************************************************************

	LI	R0,INTVEC		;SET UP INTERRUPT VECTORS
	LI	R1,INTTAB		;ONLY INT 2 TO 4 
INT1:	NOP
	MOV	*R1+,*R0+
	MOV	*R1+,*R0+
	CI	R0,INTVEC+12
	JNE	INT1
	LI	R0,40H			;INITIALISE XOP-START AT XOP0
	LI	R1,XOPTAB
INIT2:	NOP				;WRITE PROTECT
	MOV	*R1+,*R0+
	NOP				;WTRITE PROTECT
	MOV	*R1+,*R0+	
	CI	R0,80H			;FINISHED?
	JNE	INIT2			;NO
;
	CALL	@WBOOT
	RTWP

;
;************************************************************
;
;	WARM BOOT ASSUMES A COLD BOOT HAS ALREADY OCCURED
;	AND DISC IS JUST BEING CALIBRATED TO A KNOW STATE
;
;************************************************************
;
WBOOT:	SETO	@TRACK			;INVALIDATE TRACK
	CLR	@SECTOR
	CLR	@DRIVE
	LI	R2,0			;SELECT BOOT DRIVE
	CALL	@SELDSK			;SELECT DISK
	CALL	@RECAL			;RECAL
	RET				;RETURN FROM BLWP
;
;*********************************************************
;
;	BOOT ASSUMES NOTHING HAS BEEN INITIALISED THEREFORE IT
;	MUST CALL MONITOR TO INITIALISE THE FDC AND INTERRUPT VECTORS ETC BY
;	CALLING BLWP @MONITOR
;
;***********************************************************
;
BOOT:	LWPI	BOOT_TWP		;WORKSP CAN'T BE THE SAME AS MONITOR THIS IS A TEMPORARY WORKSPACE
	BLWP	@MONORG		;PERFORM INITIALISATION AND WARM BOOT
	LI	R10,BOOT_TWP-2	;JUST PUT THE TEMPOARY STACK ABOVE THE WORKSPACE
;
;---NOW TRY TO BOOT FROM TRACK 0 SECTOR 1
;
	MESG	@BMSG2
	CLR	R2
	CALL	@SELDSK		;SELECT DRIVE A
	JNE	BOOT2
	CALL	@RECAL		;RECAL DRIVE A
	LI	R3,1		;BOOT SECTOR
	LI	R4,LOADER		;USE THIS AREA TO BOOT
	CALL	@RDREC
	JNE	BOOT2
	B	@LOADER		;LET THERE BE LIFE - LOAD THE SYSTEM
;
; --BOOT ERROR
;
BOOT2	MOV	R1,@FDCSTATUS
	MESG	@BMSG1
	B	@TIMON
;
BMSG1	TEXT	'--Boot error'
	BYTE	0DH,0AH,0
	EVEN
BMSG2	TEXT	'--Booting....'
	BYTE	0DH,0AH,0
	EVEN

;
;****************************
;
; CHAR IN (MSB	OF R1)
;
;*****************************	
CIN	READ	R1	 		;GET CHAR
	RET
;*******************************
;
;	CHAR OUT (MSB OF R2)
;
;********************************
;
COUT	CLR	R1
	MOVB	R2,R1	 		;COPY CHAR TO R1
	WRITE	R1	 		;OUTPUT IT
	RET	 
;
;************************************************
;
;	SELECT THE DRIVE IN R2
;
;************************************************
;
SELDSK:	CI	R2,1			;MAXIMUM NUMBER IS 2
	JGT	SELRET
	CALL	@DRVSEL			;SELECT THE DRIVE
	CALL	@READY			;EMIT NEW SELECT BITS AND TEST READY
	JNE	SELRET
	MOV	R1,R1
	JNE	SELRET			;NOT READY
	MOV	@DRIVE,R3			;SAVE LAST UNIT
	SLA	R3,1			;TWO BYTES PER WORD
	MOV	R2,@DRIVE			;NEW UNIT
	MOV	@TRACK,@TRKTAB(R3)		;STORE PREVIOUS DRIVES TRACK POSITION
	MOV	@DSKTYP,R1
	ANDI	R1,00000011B
	MOV	R1,@TYPTAB(R3)		;STORE PREVIOUS DISK TYPE
	LI	PORT,TRKREG
	SLA	R2,1			;MULTIPLY BY 2, IE TWO BYTES PER WORD
	MOV	@TRKTAB(R2),R1		;GET LAST KNOWN HEAD POSITION FOR NEW DRIVE
	MOV	R1,@TRACK			;SAVE THE DRIVE'S NEW POSITION AND
	SWPB	R1
	LDCR	R1,BYTEWIDE 		;OUTPUT TO THE 1797 FDC
	MOV	@DSKTYP,R1			;DENSITY BITS ETC
	ANDI	R1,11111100B		;MERGE IN NEW DENSITY CONTROL BIT
	SOC	@TYPTAB(R2),R1
	CALL	@SETDENS			;SET DENSITY CONTROL BIT
SELRET:	BLWP	@SETTIMER			;SET DRIVE TIMER
	RET
;
;	OUTPUT SELECT BITS
;
DRVSEL:	ANDI	R2,00000011B		;MAKE SURE IT'S IN RANGE	
	MOVB	@SELTAB(R2),@SELCPY		;STORE NEW STATE OF SELECT/MUX PORT
	RET
;
SELTAB:	BYTE	00000001B			;BITS FOR UNIT # 0
	BYTE	00000010B
	BYTE	00000100B
	BYTE	00001000B
;
; TURN OFF ALL DRIVES
;
DESELECT: 	LI	PORT,SELMUX
	CLR	R0
	LDCR	R0,00000101B		;CLEAR DISKS
	RET

;
;	EMIT MUX BITS AND SEE IF DRIVE IS READY
;
READY:	LI	R1,1
	MOV	R1,@INUSE		;SET DISK-ACTIVE FLAG
	LI	PORT,SELMUX		;SELECT PORT
	CLR	R1
	LDCR	R1,5		;CLEAR SELECT BITS FIRST
	LDCR	@SELCPY,5		;;OUTPUT CURRENT DRIVE SELECT/MUX BITS
	MOV	@TIMEOUT,R0
	CI	R0,1
	JNE	READY1
	CALL	@FORCE
	ANDI	R1,10000000B
	JNE	READY2
READY1:	CALL	@WAITRDY
	CALL	@FORCE		;CLEAR CONTROLLER AND TEST DRIVE
	ANDI	R1,10000000B	;READY FLAG
READY2:	MOV	R1,@FDCSTATUS
	RET
;
;
FORCE:	LI	R1,FINTCMD		;FORCE INTERRUPT COMMAND
	CALL	@EXCMD
	LI	PORT,STSREG		;GET RESULT BYTE AS NO INTERRUPT
	STCR	R1,BYTEWIDE		;HAS OCCURRED
	SRL	R1,8
	RET
;
;*****************************
;
;--RECAL IS JUST SEEK TO TRK ZERO (RECAL IS HANDLED THERE)
;
;*****************************
;
RECAL:	LI	R3,0			;RECAL COMMAND
	SETO	@TRACK			;INVALIDATE TRACK SEEK WILL ZERO
	CALL	@SEEK			;TRACK REGISTER IS ZEROED
	ANDI	R1,10000001B
	RET
;
;*******************************
;
;READ ID FIELDS
;
;******************************
;
RDID	MOV	R4,@IOPTR
	CALL	@READY
	JNE	RDIDX
	LI	R2,RIDCMD
	CALL	@RDWRT			;READ ID RECORD INTO (R4)
	JNE	RDIDX			;EXIT IF DISK ERROR
	MOV	@IOPTR,R4
	AI	R4,6			;POINT TO 7TH BYTE AFTER ID RECORD
	MOV	@DSKTYP,*R4		;STORE DISK TYPE THERE
RDIDX	BLWP	@SETTIMER
	RET
;
;****************************
;
;READ A RECORD
; 	R3 HOLDS SECTOR
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
RDREC:	MOV	R4,@IOPTR
	MOV	R3,@SECTOR
	CALL	@READY
	JNE	RDRECX		;EXIT IF DRIVE NOT READY
	LI	R2,RDCMD		;DO A READ COMMAND
	CALL	@RDWRT
RDRECX:	BLWP	@SETTIMER
	RET			;BIND	*SP+ ;RET
;****************************
;
;READ A TRACK
; 	R3 NOT REQUIRED
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
RDTRK	MOV	R4,@IOPTR
	LI	R3,1		;DUMMY
	MOV	R3,@SECTOR
	CALL	@READY
	JNE	RDTRKX		;EXIT IF DRIVE NOT READY
	LI	R2,RTCMD		;DO A READ COMMAND
	CALL	@RDWRT
RDTRKX	BLWP	@SETTIMER
	RET			;BIND	*SP+ ;RET;
;
;****************************
;
;WRITE A TRACK
; 	R3 NOT REQUIRED
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
WRTRK	MOV	R4,@IOPTR
	MOV	R3,@TRACK
	CALL	@READY
	JNE	RDTRKX		;EXIT IF DRIVE NOT READY
	LI	R2,WTCMD	;DO A WRITE COMMAND
	CALL	@RDWRT
WRTRKX	BLWP	@SETTIMER
	RET			;BIND	*SP+ ;RET;
	;
;******************************
;
;WRITE A RECORD
; 	R3 HOLDS SECTOR
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
WRREC	MOV	R4,@IOPTR
	MOV	R3,@SECTOR
	CALL	@READY
	JNE	WRRECX
	LI	R2,WRCMD
	CALL	@RDWRT
WRRECX	;BLWP	@SETTIMER
	RET
;
; SECTOR TRANSLATE (NOT NEEDED ANYMORE MAY 2010)
; SO  JUST RETURN
;
;SECTRAN	RET			;NOT NEEDED WITH IBM FORMATS
;	ANDI	R3,000FH
;	DEC	R3		; 0 -> 8
;	AI	R3,SETTBL
;	MOVB 	*R3,R0
;	MOV	R0,R3
;	SRL	R3,8
;	RET
;SETTBL	BYTE	1,4,7,2,5,8,3,6,9	;1,4,7,9,2,5,8,3,6
;	EVEN
;
;
;********************************
;
;	COMMON READ AND WRITE ROUTINE (RDWRT)
;	ENTER WITH 
;		R4 -> IO BUFFER
;		R3 -> SECTOR
;		R2 -> COMMAND TYPE
;
;	ASSUME THE CORRECT TRACK IS UNDER THE DISK HEAD
;
;	TREAT DRQINT AS A PSUEDO DMA CHANNEL
;	BY LOADING THE PORT REGISTER(R12) WITH THE
;	I/O ADDRESS AND THE TYPE OF OPERATION I.E. READ/WRITE
;	THERE IS NO COUNT AS I RELY ON AN INTERRUPT FROM THE
;	FDC1797 TO TERMINATE THE TRANSFER.
;
;*********************************
;
RDWRT:	;LI	R0,6
	;MOV	R0,@07B0H+6

	MOV	R2,@CMDTYP		;SAVE READ/WRITE/READID COMMAND
	MOV	@MAXRWT,@RWTRY	;SET READ/WRITE RETRY
RDWRT0:	MOV	@SECTOR,R3
	LI	PORT,SECREG		;FDC SECTOR REGISTER
	SWPB	R3
	LDCR	R3,BYTEWIDE
;
;	SET UP PSUEDO DMA CHANNEL
;
	CLR	R3			;INDEX POINTER
	LI	R0,DATREG		;FDC REG WHERE DATA IS
	MOV	R0,@DMAPORT
	MOV	@IOPTR,@DMAADDR		;DMA TRANSFER ADDRESS
	MOV	@CMDTYP,R1
	CI	R1,WRCMD		;WRITE COMMAND ?
	JEQ	RDWRT1			;YES
	CI	R1,WTCMD		;WRITE COMMAND ?
	JEQ	RDWRT1			;YES
	MOV	@CMDTBL(R3),@DMACMD	;EXECUTE A READ COMMAND (STCR)
	JMP	RDWRT2
RDWRT1:	INCT	R3
	MOV	@CMDTBL(R3),@DMACMD	;EXECUTE A WRITE COMMAND (LDCR)
;
;
;--MERGE SIDE BIT BEFORE COMMAND IS EXECUTED
;
RDWRT2:	CI	R1,RIDCMD		;IF ID CMD DON'T NEED TO MERGE
	JEQ	RDWRT5
	MOV	@SIDE,R0		;GET SIDE BIT
	SLA	R0,1
	SOC	R0,R1		;OR IN SIDE BIT INTO COMMAND BYTE
RDWRT5:	CALL	@EXCMD
	ANDI	R1,11011111B	;MASK READY/WRITEPROTECT/RNF/CRC/OVERRUN/DRQ/BUSY
	JEQ	RDWRT4		;RETURN IN NO DISK IO ERROR

DSKERR:	;LI	R0,8
	;MOV	R0,@07B0H+8

	MOV	R1,@ERRTYP
	CALL	@RECOVER		;DO READ/WRITE ERROR RECOVERY
	JNE	RDWRT3		;DON'T RETRY IF UN-RECOVERABLE ERROR
	DEC	@RWTRY		;ELSE DECREMENT AND KEEP TRYING UNTIL 0
	JNE	RDWRT0
RDWRT3:	MOV	@ERRTYP,R1
	B	@IOERR
RDWRT4:	RET
;
;***************************************
;
;	ATTEMPT TO RECOVER FROM A READ WRITE
;	ERROR
;
;****************************************
;
RECOVER	MOV	R1,R2			;COPY ERROR CODE TO R2
	ANDI	R2,10000111B		;ISOLATE REAY/OVERRUN/DRQ/BUSY ERRORS
	JEQ	RECOV1			;JUMP IF NONE OF THOSE SET
	MOV	R1,R2
	CALL	@FORCE			;CLEAR ERROR FLAGS IN 1797
	MOV	R2,R1
RECOV0	RET
;
;	ARRIVE HERE IF CRC OR RNF ERROR
;
RECOV1	MOV	R1,R2
	ANDI	R2,00010000B		;SECTOR ID NOT FOUND
	JEQ	STEP
	ANDI	R2,00100000B		;RNF ERROR
	JEQ	RECOV3
	RET				;PROCESS ID NOT FOUND ERROR
;
;	ARRIVE HERE ON BAD CRC IN DATA OR ID FIELD
;
STEP:	C	@RWTRY,@MAXRWT		;CHECK FOR FIRST TIME
	JEQ	RECOV0
	LI	R1,SICMD			;STEP BACK AND FORTH
	CALL	@EXCMD
	LI	R1,SICMD			;STEP IN TWO TRACKS THEN BACK
	CALL	@EXCMD
	LI	R1,SOCMD
	CALL	@EXCMD
	LI	R1,SOCMD
	CALL	@EXCMD
	CALL	@VERIFY
	RET				;RETURN WITH STATUS IN R1
;
;	ARRIVE HERE IF RNF ERROR
;
RECOV3 	PUSH	@DSKTYP			;SAVE DENSITY CONTROL BYTE
	CALL	@VERIFY			;TRACK VERIFY USING READ - ID
	POP	R3			;KEEP PREVIOUS DENSITY BYTE HERE
	JEQ	RECOV4			;RETURN IF NO ID MARK FOUND
	RET
;
RECOV4	C	@DSKTYP,R3		;SEE IF DENSITY WAS CHANGED BY 'VERIFY'
	JEQ	RECOV5			;AND EXIT WITH RNF IF NOT
	CLR	R1
	MOV	R1,R1			;CLEAR R1 TO INDICATE A RETRY SHOULD BE
	RET				;DONE NOW THAT DENSITY IS RIGHT
;
RECOV5	LI	R1,00010000B             ;HEX 0010H
	MOV	R1,R1			;INDICATE ERROR DUE TO NON-EXISTENT
	RET				; SECTOR OR INDETERMINATE TRACK
;
; VERIFY WE ARE TRACK
;
VERIFY	LI	R1,RIDCMD
	CALL	@EXCMD			;READ NEXT ID-MARK TO VERIFY SEEK
	ANDI	R1,10011001B
	JEQ	VERFY2			;JUMP IF ID MARK READ SUCCESSFULLY
	CALL	@FLIPDENS			;ELSE SWITCH DISK DENSITY CONFIGURATION
	LI	R1,RIDCMD
	CALL	@EXCMD			;TRY AGAIN
	ANDI	R1,10011001B
VERFY2	MOV	R1,R5			;SAVE STATUS OF READ-ID COMMAND
	CALL	@FORCE			;CLEAR OVERRUN AND DRQ BITS IN 1797
	MOV	R5,R1
	JNE	VERFY3			;RETURN IF ID MARK WAS FOUND
	RET
VERFY3	CALL	@SETDENS			;ELSE GO BACK TO ORIGINAL DENSITY
	MOV	R5,R1			;RETURN WITH ERROR INDICATED
	RET
;
;********************************
;
;INTIALISE	INT.VECTORS	ETC	
;
;*******************************
;
INTSYS	RET
;
;********************************
;
;RESET	FDC
;
;********************************
;
RSET	RET
;
;
;*******************************************
;
; 	SET THE TIME OUT TIMER
;
SETTIMER 
	WORD	INTWP4,SETTIMER+4
	LI	PORT,0080H
	SBZ	20			;RESET INTERRUPT
	LI	R8,200			; 200 X 16MS = 7.0SEC
	MOV	R8,@TIMEOUT
	SBZ	14
	SBO	13			;LOAD INTERVAL TIMER ONLY
	LDCR	@INTLV2,8
	SBO	20			;ENABLE INTERRUPT
	RTWP
;
INTLV2	BYTE	255			;16.0 MILLISECONDS
	EVEN
;
;ALLOW TIME FOR USER TO INSERT DISC (IN FUTURE MAY INCREASE THE TIMEOUT)
;
WAITRDY:
	CALL	@FORCE
	LI	PORT,STSREG
	SETO	@DRVRDY			 ;ALLOWS US TO TIMEOUT
;
WAITRDY1:
	STCR	R0,BYTEWIDE
	ANDI	R0,8000H
	JEQ	WAITRDY2
;
;	WAIT FOR 32uS FOR DRIVE TO BECOME READY
;
	DEC	@DRVRDY
	JNE	WAITRDY1
WAITRDY2:
	RET
;
;******************************************
;
;	SET DENSITY BIT 
;
;******************************************
;
SETDENS:	MOV	R1,@DSKTYP
	LI	PORT,TYPMUX
	SWPB	R1
	LDCR	R1,2		;OUTPUT CONTROL BITS
	CLR	R1
	MOV	R1,R1
	RET

	;
;******************************************
;
;	FLIP DENSITY BIT
;
;******************************************
;
FLIPDENS:	MOV	R1,@DSKTYP
	LI	PORT,TYPMUX
	SWPB	R1
	LDCR	R1,0		;OUTPUT CONTROL BITS
	CLR	R1
	MOV	R1,R1
	RET
;
;;*******************************************
;
;	SEEK TO THE TRACK NUMBER HELD IN R3
;
;	DRIVE # IS IN DRIVE
;
;********************************************
;
SEEK:	CALL	@READY		;SEE IF DRIVE IS READY FIRST
	JNE	SEEKX		;ERROR CONDITION IN OPSTAT
	CLR	@SIDE		;ASSUME SIDE 0		
	TCMB	R3,0		;TEST AND CLEAR MSB
	STST	ST
	JNE	SEEK0		;SIDE 0
	INC	@SIDE		;SIDE 1
SEEK0:	C	R3,@TRACK		;ARE WE ALREADY THERE ?
	JEQ	SEEKX		;STAT WILL SHOW OKAY
	MOV	@TRACK,R1
	CI	R1,-1		;IF NOT KNOWN TRACK RECAL DRIVE
;	JNE	SEEK3
	CLR	@SIDE		;ASSUME SIDE 0
	LI	R1,RSTCMD
	CALL	@EXCMD		;EXECUTE RESTORE COMMAND AT SLOWEST STEP SPEED
	LI	R0,00000100B	;TRK00 BIT
	XOR	R0,R1		;MAKE TRK00 BIT TRUE
	ANDI	R1,10000101B	;NOT FOUND AND NOT READY BITS
	JNE	SEEKX		;EXIT IF RESTORE CANNOT BE DONE

SEEK2:	LST	ST
	JNE	SEEK3
	INC	@SIDE

SEEK3:	MOV	R3,@TRACK
	LI	PORT,DATREG		;ALSO PUT IN 179X TRACK REGISTER
	SWPB	R3
	LDCR	R3,BYTEWIDE		;OUTPUT TO FDC PORT
	LI	R1,SEKCMD
	CALL	@EXCMD
	ANDI	R1,10010000B	;NOT FOUND & NOT READY ERROR
	JEQ	SEEKX
	SETO	@TRACK

SEEKX:
	MOV	R1,R1		;INDICATE RESULT TYPE
	RET
;
;
;RETURN WITH COMPLETION STATUS IN ACC
;
;	EXECUTE THE COMMAND IN REGISTER R1
;
;
EXCMD:	LIMI	3		;DISABLE INTERRUPTS
	LI	PORT,CMDREG
	SWPB	R1
	LDCR	R1,BYTEWIDE		;OUTPUT CONTROLLER COMMAND
;	LIMI	3		;ENABLE FDC INTERRUPTS ONLY
	LI	R0, 40		;DELAY AROUND 60uS BEFORE READING STATUS
EXCMD1:	DEC	R0
	JNE	EXCMD1
	CI	R1,FINTCMD*256	;IF FORCE INTERRUPT EXIT
	JEQ	EXCMD3
;	CI	R1,RDCMD*256
;	JNE	EXT
;
;--WHEN THE FDC COMPLETION INTERRUPT ROUTINE IS ENTERED THIS TEMPORARY
;  HALT INSTRUCTION WILL BE BYPASSED
;
	SETO	@OPCOMP
EXCMD4A	MOV	@OPCOMP, R1		;TIMEOUT WILL ALSO CLEAR THIS
	JNE	EXCMD4A		;USE FDCINT TO BUMP PAST THIS ADDRESS
	MOV	@FDCSTATUS,R1		;STATUS REGISTER RESULT
EXCMD3	LIMI	4		;THIS ENABLES TIMER INTERRUPT
	RET
;
;************************************************
;
;WRITE	ERROR	MESSAGE
;
;**************************************************
;
IOERR:	MESG	@ERRMSG	
	WHEX	R1	 		;O/P TYPE
	MESG	@DRVMSG			;DISK MESSAGE
	WHEX	@DRIVE			;DRV #
	MESG	@TRKMSG			;TRACK #
	WHEX	@TRACK
	MESG	@SECTMSG	 	;SECTOR MESSAGE
	WHEX	@SECTOR			;SECTOR #
	SETO	R1
	RET
;	B	@TIMON			;FATAL 
;
;
;******************************
;
;	MAIN INTERRUPT ROUTINES
;
;********************************
;
INTREQ 	LI	PORT,STSREG
	CLR	R8
	STCR	R8,BYTEWIDE
	SWPB	R8
	MOV	R8,@FDCSTATUS		;SHOW RESULT OF OPERATION
	JMP	INTREQ1
	
;CHECK TRACK REGISTER
	LI	PORT,TRKREG
	CLR	R8
	STCR	R8,BYTEWIDE
	SWPB	R8
	MOV	R8,@TRKSTAT
;CHECK SECTOR REGISTER
	LI	PORT,SECREG
	CLR	R8
	STCR	R8,BYTEWIDE
	SWPB	R8
	MOV	R8,@SECSTAT	
INTREQ1	CLR	@OPCOMP		;SHOW THAT THE INTERRUPT WAS EXECUTED
	RTWP
;
;***********************************
;
;	THIS INTERRUPT SIMULATES DMA CONTROL
;	ORGANISED AS FOLLOWS:
;
;	R9 HOLDS CURRENT COMMAND I.E. STCR OR LDCR
;	R8 HOLDS THE CURRENT DMA ADDRESS.
; 	R12 HOLDS THE CURRENT IO PORT - GENERALLY DATREG
;
INTDRQ	X	R9		;EXECUTE THE COMMAND SPECIFIED BY RDWRT
	RTWP
;
;*********************************************************************
;
;	THIS INTERRUPT IS CONTROLED BY THE TIMER
;
;**********************************************************************
;
TIMEOUT	WORD 	1		;N * 16MS DURATION
INTTIMER 	
	LI	PORT,0080H
	TB	25
	JNE	TIME2
	SBO	20		;RESET INTERRUPT
	DEC	@TIMEOUT
	JNE	TIME2
	INC	@TIMEOUT
	SBZ	20		;DISABLE TIMER
	LI	PORT,SELMUX
	CLR	R8
	LDCR	R8,5		;CLEAR DISKS
TIME2	RTWP
;
;***********************************************************************
;
;	MESSAGES
;
;************************************************************************
;
ERRMSG	BYTE	0DH,0AH,20H
	TEXT	'FDC error type: '
	BYTE	0
STKMSG	BYTE	0DH,0AH,20H
	TEXT	'Stack overflow at: '
	BYTE	0
DRVMSG	TEXT	' Drive: '
	BYTE	0
TRKMSG	TEXT	' Track: '
	BYTE	0
SECTMSG	TEXT	' Sector: '
	BYTE	0
;
;***************************************************************************
;
;	ALL XOP's AND WORKSPACES ARE DEFINED IN THIS SECTION AND ARE USED BY ALL PROGRAMMES
;	THAT INTERACT WITH THE MONITOR ROUTINES
;
;	NOTES.
;		1. ALL INTWP'S AND XOPWP'S OVERLAP AND SO ANY INT OR XOP
;	      	   FUNCTIONS MAY ONLY USE REGISTERS R8-R10. REGISTERS R11
;	      	   TO R15 ARE RESERVED FOR XOP & INT LINKAGES.
;
;		2. THE XOP WORKSPACES ARE JUST FOR MANAGING THE STACK AND CONTEXT
;		   CALLS THE ORIGINAL WP IS PRESERVED AFTER THE CALL, WHICH MEANS
;		   THAT CALLING ROUTINES SHARE THE SAME REGISTERS.
;
;		3. EVEN THOUGH R9 & R10 ARE GENERALLY USED AS STACK REGISTERS
;		   THIS DOES NOT APPLY IN INTERRUPT WORKSPACE WHERE THEY CAN'T
;		   BE USED FOR THAT PURPOSE - SIMPLY BECAUSE THE STACK POINTER 
;		   IS NOT PASSED TO THE NEW WORKSPACE.  THEY CAN BE COPIED USING
;		   THE R13 INDEX IF NEEDED AS R13 POINTS TO THE CALLING ROUTINE'S WORKSPACE
;
;*****************************************************************************
;
	EVEN
INTWP0	EQU	$ + 0		;INTERRUPT WORKSPACE
INTWP1	EQU	INTWP0+16		;ONLY 7 ALLOWED
INTWP2	EQU	INTWP1+16
INTWP3	EQU	INTWP2+16
INTWP4	EQU	INTWP3+16
INTWP5	EQU	INTWP4+16
INTWP6	EQU	INTWP5+16
INTWP7	EQU	INTWP6+16
;
;    NOW XOP'S
;
XOPWP0	EQU	INTWP7+16
XOPWP1	EQU	XOPWP0+16
XOPWP2	EQU	XOPWP1+16
XOPWP3	EQU	XOPWP2+16
XOPWP4	EQU	XOPWP3+16
XOPWP5	EQU	XOPWP4+16
XOPWP6	EQU	XOPWP5+16
XOPWP7	EQU	XOPWP6+16
XOPWP8	EQU	XOPWP7+16
XOPWP9	EQU	XOPWP8+16
XOPWP10	EQU	XOPWP9+16
XOPWP11	EQU	XOPWP10+16
XOPWP12	EQU	XOPWP11+16
XOPWP13	EQU	XOPWP12+16
XOPWP14	EQU	XOPWP13+16
XOPWP15	EQU	XOPWP14+16
;
	AORG	XOPWP15+32

;
;
;	DEFINE ALL THE XOP ROUTINES
;
XOP0	RTWP
XOP1	RTWP
XOP2	RTWP
XOP3	RTWP
;XOP15	RTWP
;
CRUBAS	EQU	80H			;TMS9902 CRU BASE
;
;**********************************************
; PUSH REGISTERS R0 to RN ONTO THE STACK
;*********************************************
;
XOP4	
	MOV	R13,R8			;GET THE EFFECTIVE ADDRESS OF CALLING WORKSPACE
	MOV	@2*R10(R13),R10		;GET SYSTEM STACK POINTER
XOP4A	DECT	R10			;DECREMENT STACK POINTER
;	C	R10,@2*R9(R13)		;CHECK FOR OVERFLOW
;	JLE	STACKERR
	MOV	*R8+,*R10
	C	R8,R11			;KEEP PUSHING REGISTERS (R11 HOLDS EFFECTIVE ADDRESS OF REGISTER RN)
	JLE	XOP4A	
	MOV	R10,@2*R10(R13)		;UPDATE THE STACK POINTER 
	RTWP
;
;***********************************************
; POPS REGISTERS R0 to RN OFF THE STACK
;************************************************
;
XOP5	MOV	@2*R10(R13),R10		;GET STACK POINTER
XOP5A	MOV	*R10+,*R11		;GET FIRST REGISTER
	DECT	R11			;DECT TWO EFFECTIVE ADDRESS, IE RN
	C	R11,R13			;COMPARE AGAINST WORKSPACE TOP ADDRESS IE R0
	JHE	XOP5A
	MOV	R10,@2*R10(R13)
	RTWP

;
;
;************************************************
;	CALL A SUBROUTINE
;	CALLING METHOD:   CALL SUBROUTINE_ADDRESS
;*************************************************
;
XOP6	MOV	@2*R10(R13),R10 		;GET STACK POINTER
	DECT	R10
;	C	R10,@2*R9(R13)		;CHECK FOR STACK OVERFLOW
;	JLE	STACKERR			;O/P STACK OVERFLOW MESSAGE
	MOV	R14,*R10			;PUSH SAVED PC ONTO STACH
;	ANDI	R14,1			;CHECK FOR ODD
;	JNE    	ODDMSG
	MOV	R11,R14			;MOVE EA INTO R14 FOR CALL
	MOV	R10,@2*R10(R13)		;UPDATE STACK POINTER
	RTWP
;
;============================================
;	SUBROUTINE RETURN
;	CALLING METHOD:	RET
;============================================
;
XOP7	MOV	@2*R10(R13),R10		;GET STACK POINTER
	MOV	*R10+,R14			;MOVE EA INTO R14 FOR CALL
	MOV	R10,@2*R10(R13)		;GET UPDATED STACK POINTER
	RTWP				;RETURN
;
;*************************************************
;	PUSH DATA/REGISTER ONTO THE STACK
;	USES CALLER'S WP AND STACK POINTERS
;*************************************************
;
XOP8	;MOV	@FREEMEM,@2*R9(R13)	;UPDATE FREE MEMORY POINTER IE STACK LIMIT
	MOV	@2*R10(R13),R10
	DECT	R10
;	C	R10,@2*R9(R13)		;CHECK FOR OVERFLOW
;	JLE	STACKERR
	MOV	*R11,*R10
	MOV	R10,@2*R10(R13)
	RTWP
;
;	POP DATA/REGISTER OFF STACK
;
XOP9	MOV	@2*R10(R13),R10
	MOV	*R10+,*R11
	MOV	R10,@2*R10(R13)
	RTWP
;
;=====================================================
;	WRITE A HEX CHARACTER
;
;	CALLING METHOD:   WHEX RN
;
;	FUNCTION: WRITE CONTENTS OF RN AS 4 HEX DIGITS 
;========================================================
;
XOP10	MOV	*R11,R12		;GET VALUE
	LI 	R9,4			;SET COUNTER TO 4 DIGITS
;
XOP10A	MOV	R12,R8			;MOVE 4 DIGITS INTO R8R 	
	SRL	R8,12			;ISOLATE HEX DIGIT
	SLA	R8,8			;BYTE ALIGN1
	CI	R8,0900H		;IS THIS NUMERIC
	JLE	XOP10B			;YES
	AI	R8,0700H		;ALPHA ADJUST
;
XOP10B	AI	R8,'0'*256		;NUMERIC TO ASCII
	WRITE	R8			;O/P THE HEX DIGIT
	SRC	R12,12			;ALIGN NEXT DIGIT
	DEC	R9			;IF FINISHED EXIT
	JNE	XOP10A
	RTWP
;
;===========================================================
;	READ IN A 16 BIT HEX CHARACTER
;
;	CALL:   RHEX RN
;
;	FUNCTION: READ  CONTENTS INTO  RN AS 4 HEX DIGITS 
;============================================================
;
XOP11	CLR	R12			;CLEAR ACCUMULATOR
XOP11A	READ	R10			;GET AN INPUT CHARACTER
	WRITE	R10			;ECHO THE CHARACTER
;
;	CHECK FOR VALID HEX INPUT
;
XOP11B	CI	R10,'0'*256		;BELOW MIN NUMERIC ?
	JL	NOTHEX			;IF YES, JUMP
	CI	R10,'9'*256		;ABOVE MAX NUMERIC ?
	JLE	GOTONE			;IF NO, JUMP
	CI	R10,'A'*256		;BELOW MIN ALPHA ?
	JL	NOTHEX			;IF YES JUMP
	CI	R10,'F'*256		;ABOVE MAX ALPHA ?
	JH	NOTHEX			;IF YES, JUMP
	AI	R10,0900H		;ALPHA ADJUST
GOTONE	SLA	R10,4			;ISOLATE DIGIT
	SRL	R10,12			;WORD ALIGN DIGIT
;
;
; DIGIT TO ACCUMULATOR
;
	SLA	R12,4		;MAKE ROOM FOR NEW DIGIT
	A	R10,R12		;ADD NEW DIGIT IN
	JMP	XOP11A		;GO GET NEXT DIGIT
NOTHEX	MOV	R12,*R11		;RETURN THE VALUE
	RTWP
;
;==================================================
;	WRITE A CHARACTER
;==================================================
;
XOP12	LI	R12,CRUBAS
	SBO	16
XOP12A	TB	22
	JNE	XOP12A
	LDCR	*R11,8
	SBZ	16
	RTWP
;
;====================================================
;	READ CHARACTER INTO LEFT BYTE (MSB)
;====================================================
;
XOP13	LI	R12,CRUBAS
XOP13A	TB	21		;RECEIVE BUFFER REG FULL ?
	JNE	XOP13A		;NO
	CLR	*R11
	STCR	*R11,8
	SBZ	18		;SHOW WE RECEIVED CHARACTER
	RTWP
;
;=========================================================
;
;	OUTPUT A NULL TERMINATED STRING
;
;==========================================================
;
XOP14	MOVB	*R11+,R12	;GET THE CHARACTER
	JEQ	XOP14A		;IF ZERO EXAT
	WRITE	R12
	JMP	XOP14		;RETURN
XOP14A	RTWP

;=================================================
	EVEN
PLUS	TEXT	'+'
	BYTE	0
DOT	TEXT	'.'
	BYTE	0
	EVEN
;
;
;************************************************
;	DEBUG AND TRACING INFORMATION
;	STORE DEBUG TRACE DATA IF DEBUG_FLAG IS SET
;
;*************************************************
;
XOP15:	MOV	@TRACER_INDEX,R8
	AI	R8,TRACER_LIST		;THIS IS THE INDEX INTO THE LIST
	MOV	R11,*R8			;SAVE THE CURRENT TRACE POINTER IN THE LIST
;	INCT	@TRACER_INDEX		;MAYBE USE THIS LATER TO STORE A SEQUENCE AND PRINT OUT LATER
;
; 	NOW SAVE THE TRACE DATA
;

	MOV	R14,*R11+			;STORE PROGRAMME COUNTER FIRST
	MOV	R15,*R11+			;STORE STATUS FIRST
	LI	R8,16			;16 REGISTERS
XOP_LOOP:	MOV	*R13+,*R11+			;COPY REGISTERS
	DEC	R8
	JNE	XOP_LOOP
	AI	R13,-32			;RESTOR WORKSPACE REGISTER LOCATION
	JMP	REGIST
;	RTWP

;
; PRINT OUT DEBUGGING/TRACE PC, STATUS AND REGISTERS
;
REGIST:	CLR	R8		;START WITH INDEX = 0
	MOV	R8,R9
	AI	R9,TRACER_LIST		;THIS IS THE STARTING ADDRESS
	MOV	*R9,R9		;GET ADDRESS

REGIST0: 	MESG	@CRLF		;PRINT INDENTATION
	MESG	@PC_REG		;PRINT "ST="
	MOV	*R9+,R7		;PRINT WORKSPACE ADDRESS
	WHEX	R7
	MESG	@ST_REG		;PRINT "ST="
	MOV	*R9+,R7		;PRINT WORKSPACE ADDRESS
	WHEX	R7
	CLR	R10
REGIST1:	MESG	@CRLF		;PRINT CR,LF
REGIST2:	LI	R7,'R'*256
	WRITE	R7		;PRINT "R"
	MOVB	@NUMTAB(R10),R7
	WRITE	R7		;PRINT REGISTER NO
	MOVB	@NUMTAB+1(R10),R7
	WRITE	R7		;PRINT REGISTER NO
	LI	R7,'='*256
	WRITE	R7
	MOV	*R9+,R7			;PRINT REGISTER CONTENTS
	WHEX	R7
	INCT	R10
	CI	R10,20H
	JEQ	XOP15_X
	LI	R7,' '*256
	WRITE	R7
	CZC	@MASK3,R10
	JEQ	REGIST1
	JMP	REGIST2

XOP15_X	MESG	@CRLF		;PRINT INDENTATION
	RTWP

WORKSP:	BSS	32	;MONITOR WORKSPACE
ST_REG	TEXT	'  ST = '
	BYTE	0
PC_REG	TEXT	'PC = '
	BYTE	0
NUMTAB	TEXT	'0 1 2 3 4 5 6 7 8 9 101112131415'
MASK3	WORD	00FH
TRACER_INDEX:
	WORD	0
TRACER_LIST: BSS	20	;DEBUG TRACE LIST

;
; END OF PROGRAMME
;
	END
	
	
